Privte声明属性后，用public声明setxx方法，getxx方法，可以通过添加if判断等，来保护数据被不合规修改。

**讲解什么是⾯面向对象编程**

- `类`
    - 就是模板，⽤来定义⼀类对象的⽅法和属性，⽐人、学生、猫，万物都是有模板，都是可
    - 以定义为类。 (类名首字⺟母大写)
- 对象
    - 类的实例化，⽐如学生这个类实例化，就是 XX同学
- `⽅法`
    - `方法是语句的集合，在一起完成⼀个功能`
    - `方法包含于类或对象中，即普通方法或者类方法`

        ```java
        修饰符 返回值类型 ⽅法名(参数类型 参数名){ ...
        ⽅法体
        ...
        return 返回值; }
        ```

- `继承
  ⼦类继承父类的特征和行为，使得⼦类对象具有父类的方法和属性
  父类也叫基类，具有公共的⽅法和属性`
- 多态
    - `同一个行为具有多个不同表现形式的能⼒`
    - `优点:减少耦合、灵活可拓展`
    - `一般是继承类或者重写⽅法实现`
- 抽象
    - 关键词abstract声明的类叫作抽象类，abstract声明的⽅法叫抽象⽅法 ⼀个类里包含了⼀个或多个抽象⽅法，类就必须指定成抽象类抽象⽅法属于⼀种特殊⽅法，只含有⼀个声明，没有⽅法体。


# JAVA面向对象中的构造函数和封装

- 什么是构造函数
    - 一种特殊的方法
    - 创建对象时用来初始化对象，每次使用new创建对象的时候，就会使用构造函数
    - 与类具有相同的名字，但是没有返回值
    - java会自动为每个类提供一个默认构造函数
    - 如果自己定义了构造函数，就不再使用默认构造函数，如果没有显示的写出默认构造函数，则会消失
    - new User（） 是构造函数，系统会在User类里面，自动形成public User（）函数。同时，可以同时存在多个构造函数。根据里面的有参，无参数，或者参数不同都可以制作多个构造函数。如果构造函数之间互相调用，务必写在函数里的第一行。用this（参数，或无参）
- 构造函数种类
    - 默认构造函数
    - 无参构造函数
    - 有参构造函数
- 构造函数的修饰符
    - public 用的最多，用来创建对象
    - private私有化构造函数，不给外部创建对象，比如工具类，或者例设计模式
    - default 默认的话，只能在当前包里面使⽤new 创建对象，⼏乎不用
- 什什么是封装
    - 封装是把过程和数据包围起来，对数据的访问只能通过已定义的接⼝口即⽅方法
    - 在java中通过关键字private，protected和public实现封装。
    - 什什么是封装?封装把对象的所有组成部分组合在⼀一起，封装定义程序如何引⽤用对象的数据， 封装实际上使⽤用⽅方法将类的数据隐藏起来，控制⽤用户对类的修改和访问数据的程度。 适当的 封装可以让代码更更容易易理理解和维护，也加强了了代码的安全性
    - 类封装
    - 方法封装
- overload(重载，过载）
    - 在⼀个类里面，⽅法名字相同，⽽参数不同，和返回类型⽆关
- override（重写，复写）
    - ⼦类对⽗类的允许访问的⽅法的实现过程进行重新编写, 返回值和形参都不能改变
        - `返回值类型，⽅方法名，参数类型以及个数`
    - `⼦子类能够根据需要实现⽗父类的⽅方法`
      ``

# **Java⾯面向对象核⼼心关键字this讲解**

- this关键字
    - 当一个对象创建后，JVM会给这个对象分配⼀个引⽤自身的指针，这个指针的名字就是 this
      只能⽤于非静态⽅法体内，静态⽅法和代码块不能出现this
    - this就是指向当前对象本身
- 使⽤用场景
    - this(参数类型1 参数名，...) 表示当前类对应的构造函数
    - 方法形参和对象的属性重名，用this来区分


# **Java面向对象编程之继承**

**讲解对象继承的概念和使⽤**

- 继承
    - 子类继承父类的特征行为，使得⼦类对象具有⽗类的⽅法和属性
      父类也叫基类，具有公共的⽅法和属性，⽣活中的例子
    - java中的继承，减少重复代码
- 格式，通过extends关键字
- 特点
    - ⼦类拥有⽗类的非private的属性和方法
    - 子类可以⽤自⼰的⽅式实现⽗类的⽅法 override(重写，覆盖)
    - 实现了代码的复⽤用
    - 重写从父类那⾥继承来的方法的，当调用⽅法时候会优先调⽤⼦类的方法(默认就近原则)
- 注意:
    - 不支持多继承，⽀持多重继承，多重继承提高了耦合性，组合优于继承
        - extends后面之后能继承一个类
    - 所有的类都是继承于 java.lang.Object，  java最顶级的类
- final关键字
    - 修饰的类，则这个类不可以被继承
    - 修饰⽅法，则这个⽅法不允许被覆盖(重写)
- super.xxx（） 指向父类，调用父类的方法

# **Java面向对象编程之继承的super关键词**

**讲解 java继承里面的super关键字**

- super关键字
- 一个引用变量，⽤于引用⽗类对象
    - 父类和子类都具有相同的命名⽅法，要调用⽗类方法时使用
    - 父类和子类都具有相同的命名属性，要调⽤⽗类中的属性时使⽤
    - super也是父类的构造函数，格式 super(参数)
    - 注意点调⽤super() 必须是类构造函数中的第⼀条语句，否则编译不通过
- 注意
    - 每个⼦类构造⽅法的第⼀条语句，都是隐含地调用super()，如果父类没有这种形式的构造函
      数，那么在编译的时候就会报错

        ```java
        public class Father {
            public Father(){
        System.out.println("father ⽆无参构造函数"); }
        }
        public class Children extends Father{
        public Children(){
        //默认存在，写和不不写都⾏行行
        super(); 
        System.out.println("Child⽆无参构造函数");
        } }
        ```

    - this()和super()都指的是对象，均不可以在static环境中使用
        - 包括：static变量，static方法，static语句块。
- 构造函数 super和this
    - this 和super在构造函数中只能有⼀个，且都必须是构造函数当中的第一行
    - 当⽗类的构造函数是⽆参构造函数时，在⼦类的构造函数中，不⽤显式super()去调⽤⽗类的构造函数
    - 当⽗类的构造函数是有参构造函数时，如果⼦类的构造函数中不写super()进行调⽤父类的构造函数，编译器会报错
- java继承后类的初始化顺序
    - 问题:静态代码块、⾮静态代码、父类/子类⽆参构造⽅法、⽗类/⼦类的⼀般⽅法

```java
public class Father {
static { System.out.println("⽗类静态代码块");
}
public Father(){
System.out.println("father ⽆参构造函数");
}
public Father(int age){ System.out.println("father 有参构造函数");
}
public void sleep(){ System.out.println("father sleep⽅法");
} }
public class Children extends Father{
static { System.out.println("Child静态代码块");
}
    public Children(){
        //super();
System.out.println("Child⽆参构造函数");
        super.sleep();
    }
public void sleep(){ System.out.println("Child sleep方法");
} }
public static void main(String[] args) {
        new Children().sleep();
}
```

# **Java⾯向对象编程之抽象**

**讲解抽象的好处，抽象类和抽象⽅法**

****

- 什么是抽象
    - 需求
        - 动物都有年龄和名称，但是吃的不⼀样，⽺吃草，⽼⻁吃肉，但是都是闭着眼睛睡觉的
        - 车，都有名称和价格，也有跑的方法，但是最高速度或者动力来源不一样
    - 当父类的某些⽅法不确定时，可以用abstract关键字来修饰该方法，即抽象方法，用abstract
      来修饰该类，即抽象类
    - 抽象类将事物的共性的东⻄提取出来，由子类继承去实现，代易扩展、易维护
    - java中的抽象类和抽象⽅方法

    ```java
    //抽象类
    abstract class 类名{
    }
    //抽象⽅法，不能有⽅法主体 abstract 返回类型 方法名();
    ```

    ```java
    public abstract class Vehicle {
        public abstract void run();
    public void stop(){ System.out.println("停在路路上");
    } }
    class Bicycle extends Vehicle{
        @Override
    public void run() { System.out.println("⼈工驱动");
    } }
    class Automobile extends Vehicle{
        @Override
    public void run() { System.out.println("汽油驱动");
    } }
    ```

- 抽象特点:
    - 抽象类的特点
        - 抽象类不能被实例化，因为抽象类中⽅法未具体化，这是一种不完整的类，所以不能直接实例化，编译⽆法通过
        - 抽象类中不一定包含抽象⽅法，但是有抽象⽅法的类必定是抽象类
        - 如果一个抽象类中可以没有抽象⽅法，这样做的⽬的是为了此类不能被实例化。
        - 抽象类的子类必须给出抽象类中的抽象⽅法的具体实现，否则⼦类也是抽象类，需要用abstract声明
        - 抽象类不能使⽤final关键字修饰，因为final修饰的类是⽆法被继承
    - 抽象方法的特点
        - 抽象类中的抽象方法只是声明，不包含⽅法体
        - 抽象⽅法不能⽤private修饰，因为抽象⽅法必须被子类实现(覆写)，⽽而private权限 对于⼦类来说是不能访问的
        - 一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象⽅法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类
    - 构造方法，类方法(即static 修饰的方法)不能声明为抽象⽅法

  # **Java⾯向对象编程之接口**

  **讲解Java里⾯的接口interface**

- 什么是接⼝
    - 是抽象方法的集合，接⼝通常以interface来声明，⼀个类通过继承接口的⽅式，从而来继承接口的抽象方法
    - 语法

    ```java
    **interface 名称 [extends 其他的接口名] { 
    // 声明变量
    // 抽象方法
    int getMoney();
    }**
    ```

    ```java
    * 接口的特点
    * 接口的方法都是抽象⽅法，默认都是 public abstract，其他修饰符都会报错
    * 接⼝中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 
    * 类描述对象的属性和方法，⽽接口则包含类要实现的⽅法
    * 接⼝无法被实例化，需要被实现才行
    * 一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类
    * 接⼝和类的区别
    * 接⼝没有构造函数
    * 接⼝里可以有静态⽅法和⽅法体
    * 接⼝中所有的方法必须是抽象⽅法(JDK8之后就不是) * 接⼝不是被类继承了，⽽是要被类实现
    * 接⼝⽀持多继承, 类不支持多个类继承
    * 接⼝的实现implements
    * 当类实现接⼝的时候，类要实现接⼝中所有的⽅法，不然类必须声明为抽象的类，使用
    implements关键字实现所有接口 
    * 语法
    ```

    ```java
    class 类名 implements 接⼝名称[, 其他接口名称, 其他接口名称]{ 
    //要实现的方法
    } 
    ```

- 注意
    - 一个类只能继承一个类，但是能实现多个接⼝
    - 接口能继承另一个接口，接口的继承使用extends关键字，和类继承⼀样
- JDK8新特性
    - interface中可以有static⽅方法，但必须有⽅法实现体，该⽅方法只属于该接口，接口名直接调用该方法
    - 接口中新增default关键字修饰的⽅法，default方法只能定义在接⼝中，可以在⼦类或⼦接⼝中被重写
    - default定义的⽅法必须有方法体
    - 父接⼝的default方法如果在子接⼝或⼦类被重写，那么子接⼝实现对象、子类对象，调⽤该方法，以重写为准
    - 本类、接口如果没有重写父类(即接口)的default方法，则在调⽤default方法时，使用⽗类定义的default方法逻辑

```java
public interface IPay{
}
// static修饰符定义静态⽅法 static void staticMethod() {
System.out.println("接⼝中的静态⽅法"); }
// default修饰符定义默认方法 ,默认⽅法不是抽象⽅法，可以不重写也可以重写 default void defaultMethod() {
System.out.println("接口中的默认⽅法"); }

// static方法必须通过接⼝类调⽤ IPay.staticMethod();
//default方法必须通过实现类的对象调⽤ new IPay().defaultMethod();
```

# **Java⾯向对象编程之Instance Of关键词和多态**

**讲解 InstanceOf关键词使用，什么是多态**

- InstanceOf 关键词
    - **是Java的一个⼆元操作符(运算符),也是Java的保留关键字**
    - 作⽤
        - 判断⼀个类是否实现了某个接口，或者判断一个实例对象是否属于一个类
        - 语法

        ```java
        //如果该object 是该class的⼀个实例，那么返回true。如果该object 不是该class的
        ⼀个实例，或者object是null，则返回false
        
        boolean result = object instanceof class
        
        参数:
          result :boolean类型。
          object :必选项。任意对象表达式。
          class:必选项。任意已定义的对象类。
        ```

        - 对象类型强制转换前的判断

        ```java
        Person p1 = new Student(); 
        //判断对象p是否为Student类的实例例 if(1p instanceof Student)
        {
        //向下转型
           Student s = (Student)p1;
        }
        ```

- ⽅法重写和重载
    - ⽅法重写 overriede
        - 子类对父类的允许访问的方法的实现过程进行重新编写,
        - 注意点
            - 返回值和形参都不能改变
            - ⽗类的成员方法只能被它的⼦类重写
            - final 和 static的方法不能被重写
            - 构造方法不能被重写
            - 访问权限不能⽐父类中被重写的方法的访问权限更低
    - 方法重载 overload
        - 一个类里⾯，**⽅法名字相同但参数不同**，返回类型可以相同也可以不同
        - ⽐如构造函数重载

**注意核⼼区分**

- override是在不同类之间的行为，overload是在同⼀个类中的行为
- 总结:Java多态
    - 同⼀个行为具有多个不同表现形式或形态的能⼒
    - 常⻅的⽅式
        - 继承⽅法重写
        - 同类⽅法重载
        - 抽象⽅法
        - 接⼝